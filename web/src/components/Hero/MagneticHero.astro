---
import { Image } from "astro:assets";
import image1 from "../../assets/landing/syshero1.png";
import image2 from "../../assets/landing/syshero2.png";
import image3 from "../../assets/landing/syshero3.png";
import image4 from "../../assets/landing/syshero4.png";
---

<div class="cursor-container">
  <Image
    format="webp"
    class="landing-image"
    src={image4}
    alt="image4"
    quality={20}
    id="image4"
  />
  <Image
    format="webp"
    class="landing-image"
    src={image3}
    alt="image3"
    quality={20}
    id="image3"
  />
  <Image
    format="webp"
    class="landing-image"
    src={image2}
    alt="image2"
    quality={20}
    id="image2"
  />
  <Image
    format="webp"
    class="landing-image"
    src={image1}
    alt="image1"
    quality={20}
    id="image1"
  />
</div>

<style lang="scss">
  .cursor-container {
    z-index: 2;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: grid;
    place-items: center;
    aspect-ratio: 1738/1232;
    width: 100%;
    height: 100%;
    // height: auto;
    // overflow: hidden;
  }

  .landing-image {
    will-change: transform;
    width: 45%;
    height: auto;
    position: absolute;
    --radius: 3px; // animation for mobile
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
  }

  .cursor-container.images-loaded .landing-image {
    opacity: 1;
  }

  @media (max-width: 768px) {
    .landing-image {
      width: 90%;
    }

    #image1 {
      animation: float 2s linear infinite;
    }
    #image2 {
      animation: float 3s linear infinite;
      animation-delay: 0.25s;
    }
    #image3 {
      animation: float 4s linear infinite;
      animation-delay: 0.5s;
    }
    #image4 {
      animation: float 5s linear infinite;
      animation-delay: 0.75s;
    }
  }
</style>

<script>
  const img1 = document.getElementById("image1");
  const img2 = document.getElementById("image2");
  const img3 = document.getElementById("image3");
  const img4 = document.getElementById("image4");

  function checkAllImagesLoaded(images, callback) {
    let loadedImages = 0;
    images.forEach((image) => {
      window.addEventListener("load", () => {
        loadedImages++;
        if (loadedImages === images.length) {
          callback();
        }
      });
    });
  }
  const images = [img1, img2, img3, img4];

  checkAllImagesLoaded(images, () => {
    const cursorContainer = document.querySelector(".cursor-container");
    cursorContainer.classList.add("images-loaded");
  });
</script>

<script>
  const lerp = (current, target, factor) =>
    current * (1 - factor) + target * factor;

  const cursorContainer = document.getElementById("magneticHero-wrapper");
  let isCursorInsideContainer = true;
  let shouldRender = true; // Added variable to control rendering

  cursorContainer.addEventListener("mouseenter", () => {
    isCursorInsideContainer = true;
  });

  cursorContainer.addEventListener("mouseleave", () => {
    isCursorInsideContainer = false;
  });

  let mousePosition = { x: 0, y: 0 };

  window.addEventListener("mousemove", (e) => {
    const container = document.querySelector(".cursor-container");
    const containerRect = container.getBoundingClientRect();

    mousePosition.x = Math.max(
      containerRect.left,
      Math.min(containerRect.right, e.clientX)
    );
    mousePosition.y = Math.max(
      containerRect.top,
      Math.min(containerRect.bottom, e.clientY)
    );
  });

  const calculateDistance = (x1, y1, x2, y2) => Math.hypot(x1 - x2, y1 - y2);

  class MagneticObject {
    constructor(domElement, { lerp, recenterLerp }) {
      this.imageElement = domElement;
      this.triggerArea = 2000;
      this.lerpFactor = lerp;
      this.recenterLerpFactor = recenterLerp;
      this.isRecentering = false;

      this.lerpingData = {
        x: { current: 0, target: 0 },
        y: { current: 0, target: 0 },
      };

      this.resizeObserver = new ResizeObserver(() => {
        this.boundingClientRect = this.imageElement.getBoundingClientRect();
      });

      const intersectionOptions = {
        root: null,
        rootMargin: "0px",
        threshold: 0,
      };

      this.intersectionObserver = new IntersectionObserver((entries) => {
        const isInView = entries[0].isIntersecting;
        if (!isInView) {
          this.pauseAnimation();
        } else {
          this.resumeAnimation();
        }
      }, intersectionOptions);
    }

    resize() {
      this.resizeObserver.observe(this.imageElement);
      this.intersectionObserver.observe(cursorContainer);
    }

    render() {
      if (!shouldRender) return;

      const { left, width, top, height } = this.boundingClientRect || {};
      const distanceFromMouseToCenter = calculateDistance(
        mousePosition.x,
        mousePosition.y,
        left + width / 2,
        top + height / 2
      );

      let targetHolder = { x: 0, y: 0 };

      if (
        isCursorInsideContainer &&
        distanceFromMouseToCenter < this.triggerArea
      ) {
        this.imageElement.classList.add("focus");

        targetHolder.x = (mousePosition.x - (left + width / 2)) * 0.2;
        targetHolder.y = (mousePosition.y - (top + height / 2)) * 0.2;

        if (this.isRecentering) {
          this.isRecentering = false;
          this.lerpingData.x.current = targetHolder.x;
          this.lerpingData.y.current = targetHolder.y;
        }
      } else {
        this.imageElement.classList.remove("focus");

        if (!isCursorInsideContainer && !this.isRecentering) {
          this.isRecentering = true;

          targetHolder.x = 0;
          targetHolder.y = 0;
        }
      }

      this.lerpingData.x.target = targetHolder.x;
      this.lerpingData.y.target = targetHolder.y;

      for (const item in this.lerpingData) {
        this.lerpingData[item].current = lerp(
          this.lerpingData[item].current,
          this.lerpingData[item].target,
          isCursorInsideContainer ? this.lerpFactor : this.recenterLerpFactor
        );
      }

      if (
        this.lerpingData.x.current !== 0 ||
        this.lerpingData.y.current !== 0
      ) {
        this.imageElement.style.transform = `translate3d(${this.lerpingData.x.current}px, ${this.lerpingData.y.current}px, 0)`;
      }

      this.resizeObserver.observe(this.imageElement);
      this.intersectionObserver.observe(cursorContainer);

      requestAnimationFrame(() => this.render());
    }

    initialize() {
      this.render();
      this.resize();
    }

    pauseAnimation() {
      shouldRender = false;
      this.imageElement.style.transform = "translate3d(0, 0, 0)";
      this.lerpingData.x.current = 0;
      this.lerpingData.y.current = 0;
    }

    resumeAnimation() {
      shouldRender = true;
      this.imageElement.style.transform = "translate3d(0, 0, 0)";
      this.lerpingData.x.current = 0;
      this.lerpingData.y.current = 0;
      requestAnimationFrame(() => this.render());
    }
  }

  const img1 = document.getElementById("image1");
  const img2 = document.getElementById("image2");
  const img3 = document.getElementById("image3");
  const img4 = document.getElementById("image4");

  const isTouchDevice =
    "ontouchstart" in window ||
    navigator.maxTouchPoints > 0 ||
    navigator.msMaxTouchPoints > 0;

  if (window.innerWidth > 576 || !isTouchDevice) {
    const magneticObjects = [
      new MagneticObject(img4, { lerp: 0.025, recenterLerp: 0.05 }),
      new MagneticObject(img3, { lerp: 0.05, recenterLerp: 0.05 }),
      new MagneticObject(img2, { lerp: 0.5, recenterLerp: 0.05 }),
      new MagneticObject(img1, { lerp: 0.1, recenterLerp: 0.05 }),
    ];

    magneticObjects.forEach((obj) => {
      obj.initialize();
    });
  }
</script>
