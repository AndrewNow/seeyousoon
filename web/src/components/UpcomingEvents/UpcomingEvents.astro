---
import ListView from "./ListView.astro";
import Sticky from "../About/Sticky.astro";

const { data } = Astro.props;
const cmsData = JSON.stringify(data.reverse()); // reverse so that the latest event comes first
---

<div>
  <div class="title-marquee" id="title-marquee">
    <h2>Upcoming Events · Upcoming Events ·</h2>
  </div>
  <div class="upcomingEvents-wrapper">
    <div class="carousel-buttons">
      <button class="carousel-card-view active">
        <p>Card view</p>
      </button>
      <button class="carousel-list-view">
        <p>List view</p>
      </button>
    </div>
    <div class="upcomingEvents-toggle-track">
      <div
        class="upcomingEvents-canvas-container"
        id="upcoming-events"
        data-cms={cmsData}
      >
      </div>
      <div
        class="upcomingEvents-list-container"
        id="upcomingEvents-carousel-slide"
      >
        <ListView cmsData={data} />
      </div>
    </div>
  </div>
  <Sticky />
</div>

<style lang="scss" is:global>
  .title-marquee {
    display: block;
    // width: 100%;
    background: var(--brown-400);
    width: 98%;
    margin: 0 auto;
    margin-top: 5rem;
    border-radius: 8px;
    overflow: hidden;
    padding-top: 3rem;
    padding-bottom: 3rem;
    h2 {
      // padding: 6rem auto;
      color: var(--beige-300);
      // background: var(--brown-400);
    }
  }
  .upcomingEvents-wrapper {
    position: relative;
    height: 105vh;
    width: 98%;
    margin: 5rem auto;
    margin-top: 1rem; // delete if not using carousel
    background: var(--brown-400);
    overflow: hidden; /* Ensure the canvas doesn't overflow the container */
    border-radius: 8px;
  }
  .carousel-buttons {
    position: absolute;
    top: 2rem;
    right: 2rem;
    z-index: 10;
    button {
      cursor: pointer;
      margin: 0 0.5rem;
      border: unset;
      background: unset;
      color: var(--grey-300);
      transition: 0.3s all ease;
    }
    button:hover {
      color: var(--grey-100);
    }
    button.active {
      color: var(--beige-300);
    }
  }
  .upcomingEvents-toggle-track {
    display: flex;
    height: 100%;
    transition: transform 0.6s cubic-bezier(0.83, 0, 0.17, 1);
    // transition: transform 0.9s cubic-bezier(0.83, 0, 0.17, 1);
  }
  .upcomingEvents-list-container {
    height: 100%;
    min-width: 100%;
    width: 100%;
    position: relative;
    display: grid;
    place-items: center;
    h1 {
      color: white;
    }
  }
  .upcomingEvents-canvas-container {
    height: 100%;
    min-width: 100%;
    position: relative;
    canvas {
      pointer-events: none;
    }
  }

  .box {
    position: absolute;
    // overflow: hidden;
    border-radius: 8px;
    background: var(--beige-100);
    outline: 1px solid var(--grey-200);
    position: relative;
    height: 250px;
    width: 500px;
    display: grid;
    place-items: center;
  }
  .upcomingEvents-inner {
    height: 80%;
    width: 90%;
    display: inline-flex;
    flex-direction: column;
    align-items: flex-start;
    justify-content: space-between;
  }
  .upcomingEvents-reserve-link {
    display: grid;
    place-items: center;
    height: 60px;
    border-radius: 6px;
    width: 100%;
    outline: 1px solid var(--grey-100);
    background: var(--beige-200);
    text-decoration: none;
    p {
      color: var(--brown-300);
    }
  }
  .upcomingEvents-header {
    h3 {
      color: var(--brown-200);
      line-height: 100%;
      padding-bottom: 1rem;
      font-size: 34px;
    }
  }
  .upcomingEvents-details {
    h6 {
      display: flex;
      align-items: center;
      padding-bottom: 0.5rem;
      font-size: 20px;
      // color: var(--brown-200);
      color: var(--grey-300);
      // white-space: nowrap;
      .svg-wrapper {
        padding-right: 0.5rem;
        aspect-ratio: 1/1;
        width: 25px;
        height: 25px;
        display: grid;
        place-items: center;
        position: relative;

        svg {
          width: 100%;
          height: 100%;
        }
      }
    }
    a {
      color: var(--grey-300);
    }
  }

  @media (max-width: 1440px) {
    .box {
      width: 490px;
      height: 235px;
    }
  }
  @media (max-width: 576px) {
    .upcomingEvents-wrapper {
      margin-top: 0.5rem;
    }
    .title-marquee {
      padding-top: 1rem;
      padding-bottom: 1rem;
    }
    .box {
      border-radius: 4px;
      width: 275px;
      height: 170px;
    }
    .upcomingEvents-header {
      h3 {
        font-size: 22px;
      }
    }
    .upcomingEvents-inner {
      height: 85%;
    }
    .upcomingEvents-details {
      h6 {
        font-size: 14px;
        .svg-wrapper {
          width: 20px;
          height: 20px;
        }
      }
    }
    .upcomingEvents-reserve-link {
      height: 40px;
    }
  }
  @media (max-width: 374px) {
    .upcomingEvents-wrapper {
      height: 150vh;
    }
  }
</style>

<script>
  // =========================
  //   toggle list view btns
  // =========================
  document.addEventListener("DOMContentLoaded", function () {
    const track = document.querySelector(".upcomingEvents-toggle-track");

    const viewCanvasEl = () => {
      // applyWindForce(7); // Adjust the force value as needed
      track.style.transform = `translateX(0%)`;
    };

    const viewListEl = () => {
      // applyWindForce(-10); // Adjust the force value as needed
      track.style.transform = `translateX(-100%)`;
    };

    const cardButton = document.querySelector(".carousel-card-view");
    cardButton.addEventListener("click", () => {
      cardButton.classList.add("active");
      listButton.classList.toggle("active");
      viewCanvasEl();
    });

    const listButton = document.querySelector(".carousel-list-view");
    listButton.addEventListener("click", () => {
      cardButton.classList.toggle("active");
      listButton.classList.add("active");
      viewListEl();
    });
  });

  //
  //
  //
  //
  //
  //
  //
  //
  import * as Matter from "matter-js";

  const containerEl = document.querySelector("#upcoming-events");
  const data = JSON.parse(containerEl.getAttribute("data-cms"));

  // =====================
  // Variable declaration
  // =====================
  let BOX_WIDTH = 550;
  let BOX_HEIGHT = 250;

  let ground, leftWall, rightWall;
  let boxArr = [];

  let engine,
    render,
    runner = null;

  const init = () => {
    // change dimensions based on browser size
    if (window.innerWidth >= 1440) {
      BOX_WIDTH = 550;
      BOX_HEIGHT = 250;
    } else if (window.innerWidth >= 576) {
      BOX_WIDTH = 490;
      BOX_HEIGHT = 235;
    } else {
      BOX_WIDTH = 275;
      BOX_HEIGHT = 170;
    }

    // create an engine
    engine = Matter.Engine.create();

    // create a renderer
    render = Matter.Render.create({
      element: containerEl,
      engine: engine,
      options: {
        width: containerEl.offsetWidth,
        height: containerEl.offsetHeight,
        wireframes: false,
        background: "transparent",
      },
    });

    // =====================
    // boundaries
    // =====================
    // create ground
    ground = Matter.Bodies.rectangle(
      containerEl.offsetWidth / 2,
      containerEl.offsetHeight,
      containerEl.offsetWidth,
      10,
      {
        isStatic: true,
        render: { fillStyle: "transparent" },
        sleep: true,
        label: "wall",
      }
    );

    // create boundaries (walls)
    leftWall = Matter.Bodies.rectangle(
      0,
      containerEl.offsetHeight / 2,
      10,
      containerEl.offsetHeight,
      {
        isStatic: true,
        render: { fillStyle: "transparent" },
        sleep: true,
        label: "wall",
      }
    );

    rightWall = Matter.Bodies.rectangle(
      containerEl.offsetWidth,
      containerEl.offsetHeight / 2,
      10,
      containerEl.offsetHeight,
      {
        isStatic: true,
        render: { fillStyle: "transparent" },
        sleep: true,
        label: "wall",
      }
    );

    // add all bodies to the world
    Matter.Composite.add(engine.world, [ground, leftWall, rightWall]);

    // =====================
    // create boxes
    // =====================

    data.forEach((cmsEntry, i) => {
      // Check if a box with the label `box${i}` already exists
      const existingBox = boxArr.find((box) => box.boxData.label === `box${i}`);

      if (!existingBox) {
        const randomX = 1.5 + Math.random() * 1.5;

        const isPositive = Math.random() < 0.5;
        const randomAngle = isPositive
          ? 3.0 + Math.random()
          : -3.0 - Math.random();

        const boxData = Matter.Bodies.rectangle(
          containerEl.offsetWidth / randomX,
          -containerEl.offsetHeight / 2,
          BOX_WIDTH,
          BOX_HEIGHT,
          {
            angle: Math.PI / randomAngle,
            label: `box${i}`,
            render: { fillStyle: "transparent" },
            restitution: 0.6,
          }
        );
        boxArr.push({ boxData, cmsEntry }); // boxdata = the physics model, cmsEntry = the data for the html boxes

        setTimeout(
          () => {
            Matter.Composite.add(engine.world, boxData);
          },
          750 * (i + 1)
        );
      }
    });

    // =====================
    // renderer
    // =====================
    Matter.Render.run(render);

    render.canvas.width = containerEl.offsetWidth;
    render.canvas.height = containerEl.offsetHeight;

    if (runner === null) {
      runner = Matter.Runner.create();
    } else {
      runner.enabled = true;
    }

    // Run the engine only if the section is in view
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            Matter.Runner.run(runner, engine);
          }
        });
      },
      {
        root: null, // use the viewport as the root
        rootMargin: "0px",
        threshold: 0.5, // 0.5 means at least 50% of the target element must be in view
      }
    );

    // Observe the container element
    observer.observe(containerEl);

    // =====================
    // box HTML setup
    // =====================
    boxArr.forEach((box, i) => {
      // Create HTML elements for boxes
      createHtmlBox(
        `box${i}`,
        box.boxData.position.x,
        box.boxData.position.y,
        box.cmsEntry
      );

      // Attach the afterUpdate event to the Runner
      Matter.Events.on(runner, "afterUpdate", function () {
        updateHtmlBox(`box${i}`, box.boxData.position, box.boxData.angle);
      });
    });

    initResize();
  };
  init();

  function resize() {
    // don't remove the walls
    Matter.Composite.allBodies(engine.world).forEach((body) => {
      if (body.label !== "wall") {
        Matter.Composite.remove(engine.world, body);
      }
    });

    // Remove HTML box elements
    boxArr = [];

    // remove the html appended to the boxes
    const htmlBoxes = document.querySelectorAll(".box");
    htmlBoxes.forEach((box) => {
      box.remove();
    });

    // Remove the canvas element from the DOM
    const canvas = containerEl.querySelector("canvas");
    if (canvas) {
      canvas.remove();
    }

    // Reinitialize the setup
    setTimeout(() => {
      init();
    }, 1000);
  }

  function initResize() {
    const debouncedResize = debounce(() => {
      resize();
    }, 2000);

    window.addEventListener("resize", debouncedResize);
  }

  function createHtmlBox(id, x, y, cmsEntry) {
    const htmlBox = document.createElement("div");
    htmlBox.id = id;
    htmlBox.className = "box";
    htmlBox.style.width = `${BOX_WIDTH}px`;
    htmlBox.style.height = `${BOX_HEIGHT}px`;
    htmlBox.style.left = `${x - BOX_WIDTH / 2}px`;
    htmlBox.style.top = `${y - BOX_HEIGHT / 2}px`;
    htmlBox.style.position = "absolute";
    htmlBox.style.zIndex = "1";

    function formatDate(inputDate) {
      const dateObject = new Date(inputDate);
      const options = { month: "long", day: "numeric" };

      const monthAndDay = dateObject.toLocaleDateString("en-US", options);
      const day = dateObject.getDate();
      let suffix = "th";

      // Handle special cases for 11 to 13 (11th, 12th, 13th)
      if (day >= 11 && day <= 13) {
        suffix = "th";
      } else {
        // For all other cases (1st, 2nd, 3rd, and 21st to 31st)
        switch (day % 10) {
          case 1:
            suffix = "st";
            break;
          case 2:
            suffix = "nd";
            break;
          case 3:
            suffix = "rd";
            break;
        }
      }

      return `${monthAndDay}${suffix}`;
    }

    function formatRange(startDate, endDate) {
      const formattedStartDate = formatDate(startDate);
      const formattedEndDate = endDate ? formatDate(endDate) : null;

      // Check if startDate and endDate have the same month
      const startMonth = new Date(startDate).getMonth();
      const endMonth = endDate ? new Date(endDate).getMonth() : null;

      if (endMonth !== null && startMonth === endMonth) {
        // If same month, omit the month name from endDate
        return `${formattedStartDate} to ${formattedEndDate.substr(formattedEndDate.indexOf(" ") + 1)}`;
      } else {
        // If different months or endDate is not provided, use both month names
        return `${formattedStartDate} to ${formattedEndDate}`;
      }
    }

    const startDate = cmsEntry.dateStart;
    const endDate = cmsEntry.dateEnd;
    const formattedDateRange = formatRange(startDate, endDate);

    htmlBox.innerHTML = `
    <div class='upcomingEvents-inner'>
      <div class='upcomingEvents-header'>
        <h3>${cmsEntry.title}</h3>
        <div class='upcomingEvents-details'>
          <h6>
            <span class='svg-wrapper'>
              <svg width="100%" height="100%" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M23.5556 24.8561H6.44444L6.44444 11.3041L23.5556 11.3041M19.8889 2.68005V5.14405L10.1111 5.14405V2.68005L7.66667 2.68005V5.14405H6.44444C5.08778 5.14405 4 6.24053 4 7.60805L4 24.8561C4 25.5095 4.25754 26.1363 4.71596 26.5984C5.17438 27.0605 5.79614 27.3201 6.44444 27.3201H23.5556C24.2039 27.3201 24.8256 27.0605 25.284 26.5984C25.7425 26.1363 26 25.5095 26 24.8561V7.60805C26 6.95456 25.7425 6.32783 25.284 5.86574C24.8256 5.40365 24.2039 5.14405 23.5556 5.14405H22.3333V2.68005M21.1111 16.2321H15L15 22.3921H21.1111V16.2321Z" fill="#9F9F9F"/>
              </svg>
            </span>
            ${formattedDateRange}
          </h6>
          <h6>
            <span class='svg-wrapper'>
              <svg width="100%" height="100%" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M15 3C10.0314 3 6 6.62869 6 11.1C6 18.3 15 27 15 27C15 27 24 18.3 24 11.1C24 6.62869 19.9686 3 15 3ZM15 15.6C14.288 15.6 13.592 15.3889 12.9999 14.9933C12.4079 14.5977 11.9465 14.0355 11.674 13.3777C11.4016 12.7198 11.3303 11.996 11.4692 11.2977C11.6081 10.5993 11.9509 9.95788 12.4544 9.45441C12.9579 8.95095 13.5993 8.60808 14.2977 8.46917C14.996 8.33027 15.7198 8.40156 16.3777 8.67403C17.0355 8.94651 17.5977 9.40793 17.9933 9.99995C18.3889 10.592 18.6 11.288 18.6 12C18.599 12.9545 18.2193 13.8695 17.5444 14.5444C16.8695 15.2193 15.9545 15.599 15 15.6Z" fill="#9F9F9F"/>
              </svg>
            </span>
            <a href=${cmsEntry.locationLink} target="_blank" rel='noreferrer'>
              ${cmsEntry.location}
            </a>
          </h6>
        </div>
      </div>
      <a class="upcomingEvents-reserve-link" href='${cmsEntry.eventLink}' target="_blank" rel='noreferrer'>
        <p>
          Reserve
        </p>
      </a>
    </div>
  `;
    document.querySelector("#upcoming-events").appendChild(htmlBox);
  }

  function updateHtmlBox(id, position, angle) {
    const htmlBox = document.getElementById(id);
    if (htmlBox) {
      const updatedX = position.x;
      const updatedY = position.y;
      const updatedAngle = angle;

      // Apply position and rotation
      htmlBox.style.left = `${updatedX - BOX_WIDTH / 2}px`;
      htmlBox.style.top = `${updatedY - BOX_HEIGHT / 2}px`;
      htmlBox.style.transform = `rotate(${updatedAngle}rad)`;
    }
  }

  function applyWindForce(force) {
    boxArr.forEach((box) => {
      Matter.Body.applyForce(box.boxData, box.boxData.position, {
        x: force,
        y: 0,
      });
    });
  }

  function debounce(func, delay) {
    let timeout;

    return function (...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), delay);
    };
  }
</script>
